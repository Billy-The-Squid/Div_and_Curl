// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel InitializePositions
#pragma kernel ComputePositions

// The position of each particle. The first _ParticlesPerStream entries come 
//  from the +x stream, the next _ParticlesPerStream from -x, etc. (see 
//  IDToStream for the order of this). 
RWStructuredBuffer<float3> _Positions;
// The global scale of each particle. Same indexing scheme as _Positions.
RWStructuredBuffer<float> _Sizes;
// Single entry, ith component holds dfi/dxi
StructuredBuffer<float3> _Divergence;


// The number of particles to display in each stream. 
int _ParticlesPerStream;
// The (worldspace) distance from the center of the detector that
// each particle starts. 
float _StartDistance;
// The (worldspace) distance that each particle will travel before disappearing. 
float _TravelDistance;
// The (worldspace) scale with which each particle begins its life. 
float _StartingSize;

// The worldspace position of the center of the detector.
float3 _CenterPosition;

float _DeltaTime;


float3 IDToStream(uint3 id) {
    float3 IDToStreamList[6] = 
    {
        float3(1, 0, 0),
        float3(-1, 0, 0),
        float3(0, 1, 0),
        float3(0, -1, 0),
        float3(0, 0, 1),
        float3(0, 0, -1)
    };
    return IDToStreamList[id.x];
}

float IDToAxis(uint3 id) {
    return id.x / ((uint) 2);
}

int IDToIndex(uint3 id) { // Assumes a valid index
    return (int) (id.x * _ParticlesPerStream + id.y);
}

[numthreads(6,1,1)]
void InitializePositions (uint3 id : SV_DispatchThreadID) {
    //// x value identifies the stream, y identifies the particle number.
    //if(id.x < (uint) 6 && id.y < (uint) _ParticlesPerStream) { // Checks that it's a valid index
    //    float distance;

    //    //_Positions[IDToIndex(id)] = 
    //}

    // The divergence along this axis (hopefully)
    float div = _Divergence[0][id.x / ((uint) 2)];

    // Check if the divergence is zero. IS THIS NECESSARY?
    if(div == 0) { // I hope this indexing thing works. 
        for(int i = 0; i < _ParticlesPerStream; i++) {
            //_Positions[id.x * _ParticlesPerStream + i] =  
            // WHAT DOES THIS EQUAL?
        }
    }

    // Set the position and size of each particle in this stream. 
    float distance;
    for(int i = 0; i < _ParticlesPerStream; i++) {
        // The distance of the particle from its starting point
        distance = i * _TravelDistance / _ParticlesPerStream;
        _Positions[id.x * _ParticlesPerStream + i] = _CenterPosition + IDToStream(id) * _StartDistance +  distance * IDToStream(id) * div / abs(div);
        _Sizes[id.x * _ParticlesPerStream + i] = _StartingSize * (_TravelDistance - distance) / _TravelDistance;
    }




    // NEXT &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
    /*
    X Do debug tests on the initial positions.  
    X Build the render shader
    Build the update kernel
    */
}


[numthreads(8,4,1)]
void ComputePositions (uint3 id : SV_DispatchThreadID)
{
    // The divergence along this axis (hopefully)
    float div = _Divergence[0][id.x / ((uint) 2)];

    if(id.x < (uint) 6 && id.y < (uint) _ParticlesPerStream) { // Checks that it's a valid index
        float distance = (_Positions[IDToIndex(id)] - _CenterPosition - IDToStream(id) * _StartDistance)[id.x / ((uint) 2)];
        
        //// The distance of the particle from its starting point
        //distance = i * _TravelDistance / _ParticlesPerStream;
        //_Positions[id.x * _ParticlesPerStream + i] = _CenterPosition + IDToStream(id) * _StartDistance +  distance * IDToStream(id) * div / abs(div);
        //_Sizes[id.x * _ParticlesPerStream + i] = _StartingSize * (_TravelDistance - distance) / _TravelDistance;

        // Warning: because past values of _CenterPosition cannot be determined, this may produce unpredictable effects with motion. 
    }
}
