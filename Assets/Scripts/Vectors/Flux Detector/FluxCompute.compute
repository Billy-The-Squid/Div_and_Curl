#pragma kernel CalculateFluxContributions
#pragma kernel CalculateTotalFluxTriangles
// Change this line back! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// How many of these can be just normal StructuredBuffers? %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// The value of the vectors, indexed the same as the positionsBuffer. 
RWStructuredBuffer<float3> _Vectors;
// The normals, hopefully in worldspace. 
RWStructuredBuffer<float3> _Normals;
// The dot product of (currently normalized) vector and normal. 
RWStructuredBuffer<float> _FluxContributions;

// The number of vertices. 
int _NumberOfPoints;
// The total flux through the object. 
RWStructuredBuffer<float> _TotalFlux;

// Things required for the Triangles kernel
int _NumberOfTriangles;
StructuredBuffer<int> _Triangles;
StructuredBuffer<float3> _Positions;
//// The total area of each triangle the vertex is adjacent to.
RWStructuredBuffer<float> _Areas;  // It's frustrating that I can't declare this dynamically. 
//// The number of triangles that each vertex contributes to. 
RWStructuredBuffer<int> _NumberOfTrianglesPerVertex;





// Calculate the dot product of the normal and field value at each point. 
[numthreads(64, 1, 1)]
void CalculateFluxContributions(uint3 id : SV_DispatchThreadID) {
	float3 normal = _Normals[id.x];
	float3 vect = _Vectors[id.x];
	float dotP = dot((vect), normalize(normal)); // We need to drop this normalization

	_FluxContributions[id.x] = dotP; // Uncomment me. 
}

//[numthreads(1,1,1)] // Add together all the contributions
//void CalculateTotalFlux(uint3 id : SV_DispatchThreadID) {
//	_TotalFlux[0] = 0;
//	for(int i = 0; i < _NumberOfPoints; i++) {
//		_TotalFlux[0] += _FluxContributions[i]; // * AreaOfTriangle;
//	}
//}

//[numthreads(1,1,1)] // Simpson's rule approximation
//void CalculateTotalFluxSimpson(uint3 id : SV_DispatchThreadID) {
//	_TotalFlux[0] = 0;
//	for(int i = 0; i < _NumberOfSubIntegrals; i++) {

//	}
//}

[numthreads(1,1,1)]
void CalculateTotalFluxTriangles(uint3 id : SV_DispatchThreadID) {
	// This could definitely be split into a couple of kernels. 

	// Iterate through the triangles.
	for(int j = 0; j < _NumberOfTriangles; j++) {
		// The index of the first vertex in the triangle. 
		int base = 3 * j;
		// The vertex numbers of the vertices in the triangle. 
		int first = _Triangles[base];
		int second = _Triangles[base + 1];
		int third = _Triangles[base + 2];

		// The area of the triangle
		float area = length(cross(_Positions[first] - _Positions[second], 
			_Positions[third] - _Positions[second]));

		_Areas[first] += area;
		_Areas[second] += area;
		_Areas[third] += area;

		_NumberOfTrianglesPerVertex[first] += 1;
		_NumberOfTrianglesPerVertex[second] += 1;
		_NumberOfTrianglesPerVertex[third] += 1;
	}

	// Iterate through the vertices to calculate the actual flux. 
	_TotalFlux[0] = 0;
	for(int i = 0; i < _NumberOfPoints; i++) {
		// average of the number of triangles adjacent * 1/3 (bc 3 vertices per triangle)
		_TotalFlux[0] += _Areas[i] * (1 / 3.0) * (1.0 / _NumberOfTrianglesPerVertex[i]) * _FluxContributions[i];
	}
}

/* 
Debug Log

System currently crashes when moving detector into field. 

Tried commenting out second for loop.
* Doesn't crash. This, uh, narrows it down. 

Uncommented that and commented out the contents of the loop alone. 
* Also doesn't crash. 

Uncomment this and have _TotalFlux[0] += 1
* Remains intact, returns 515

Allow _Areas[i] into the Uncommented portion
* Seems healthy. Returning a value around 0.7? This is...weird, considering what we expect the area of a 0.02-radius sphere to be.
* We'll have to come back to this. %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
* Varies slightly with motion. 

Allow the division in. 
* Returning about 0.24. Not the area we expect, again. 

Multiply by _NumberOfTrianglesPerVertex[i], to check whether we can access it all right. 
* Functional, returning about 1.8. Which means each vertex is connected to, on average, nine trianges? 
* That's not right %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Remove last step, uncomment division. This *should* give us the area.
* Not crashing, returning about 0.05

Uncomment multiplication by _FluxContributions
* Still not crashing? But the value is significantly varying with position, which it maybe shouldn't? 



New goals: 
* Get flux in outwards field to near-constant. 
* Get area-only version of flux consistent with what it should be. 

Maybe the dot product normalization is messing with stuff? Removing that. 
* Surprisingly fine. Reasonable colors, still functioned. 
* Less variation, but still some abnormalities. 

Creating a plane flux detector. 
* Behaves just fine. Only generates field on one side of it, which is as expected. Contributions array seems constant (from first three values), 
	as is expected from the field type.

Improving plane flux detector: unpacking, setting correct collider, removing inner surface. 




Next: add debug outputs for the normals and examine those. 

Uncommented normalize debugger and examined the outputs for the plane. 
* When unrotated, gives (0.0, 1.0, 0.0). Similarly, when rotating, gives the outputs expected. 

Re-disable the plane and reinstate the sphere. 
Enter debug mode, set a debug array + breakpoint to the positions, and try to figure out which vertex is at index 0. 
* Well, there's at least one redundancy: points 0, 406, and 494 are identical. They're all at 
	(0.6, -0.6, -0.6), and identical to seven decimal places.m 
*/